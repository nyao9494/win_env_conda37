{"version":3,"file":"tokens.js","sourceRoot":"./@jupyterlab/git/src/","sources":["tokens.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,gBAAgB,EAAE,MAAM,sBAAsB,CAAC;AACxD,OAAO,EAAkC,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAI1E,MAAM,CAAC,MAAM,YAAY,GAAG,+BAA+B,CAAC;AAE5D,MAAM,CAAC,MAAM,aAAa,GAAG,IAAI,KAAK,CAAgB,YAAY,CAAC,CAAC;AAuZpE,MAAM,KAAW,GAAG,CAiUnB;AAjUD,WAAiB,GAAG;IA4RlB;;OAEG;IACH,MAAa,gBAAiB,SAAQ,gBAAgB,CAAC,aAAa;QAClE;;WAEG;QACH,YACE,QAAkB,EAClB,OAAO,GAAG,qBAAqB,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,UAAU,EAAE,EACvE,SAAS,GAAG,EAAE,EACd,OAA2B,EAAE;YAE7B,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACzB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC,CAAC,2CAA2C;YACvE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QACpB,CAAC;QAED;;WAEG;QACH,IAAI,IAAI;YACN,OAAO,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;KAQF;IA5BY,oBAAgB,mBA4B5B,CAAA;IACD,MAAa,eAAgB,SAAQ,KAAK;QACxC;YACE,KAAK,CAAC,yBAAyB,CAAC,CAAC;QACnC,CAAC;KACF;IAJY,mBAAe,kBAI3B,CAAA;AACH,CAAC,EAjUgB,GAAG,KAAH,GAAG,QAiUnB;AAED;;GAEG;AACH,MAAM,CAAN,IAAY,KAMX;AAND,WAAY,KAAK;IACf,wCAAY,CAAA;IACZ,kCAAS,CAAA;IACT,wCAAY,CAAA;IACZ,wCAAY,CAAA;IACZ,oCAAU,CAAA;AACZ,CAAC,EANW,KAAK,KAAL,KAAK,QAMhB","sourcesContent":["import { IChangedArgs } from '@jupyterlab/coreutils';\nimport { DocumentRegistry } from '@jupyterlab/docregistry';\nimport { ServerConnection } from '@jupyterlab/services';\nimport { JSONObject, ReadonlyJSONObject, Token } from '@lumino/coreutils';\nimport { IDisposable } from '@lumino/disposable';\nimport { ISignal } from '@lumino/signaling';\n\nexport const EXTENSION_ID = 'jupyter.extensions.git_plugin';\n\nexport const IGitExtension = new Token<IGitExtension>(EXTENSION_ID);\n\n/** Interface for extension class */\nexport interface IGitExtension extends IDisposable {\n  /**\n   * The list of branch in the current repo\n   */\n  branches: Git.IBranch[];\n\n  /**\n   * The current branch\n   */\n  currentBranch: Git.IBranch;\n\n  /**\n   * A signal emitted when the `HEAD` of the Git repository changes.\n   */\n  readonly headChanged: ISignal<IGitExtension, void>;\n\n  /**\n   * Top level path of the current Git repository\n   */\n  pathRepository: string | null;\n\n  /**\n   * A signal emitted when the current Git repository changes.\n   */\n  readonly repositoryChanged: ISignal<IGitExtension, IChangedArgs<string>>;\n\n  /**\n   * Test whether the model is ready;\n   * i.e. if the top folder repository has been found.\n   */\n  isReady: boolean;\n\n  /**\n   * A promise that fulfills when the model is ready;\n   * i.e. if the top folder repository has been found.\n   */\n  ready: Promise<void>;\n\n  /**\n   * Files list resulting of a Git status call.\n   */\n  readonly status: Git.IStatusFileResult[];\n\n  /**\n   * A signal emitted when the current status of the Git repository changes.\n   */\n  readonly statusChanged: ISignal<IGitExtension, Git.IStatusFileResult[]>;\n\n  /**\n   * A signal emitted whenever a model task event occurs.\n   */\n  readonly taskChanged: ISignal<IGitExtension, string>;\n\n  /**\n   * Add one or more files to the repository staging area.\n   *\n   * ## Notes\n   *\n   * -   If no filename is provided, all files are added.\n   *\n   * @param filename - files to add\n   * @returns promise which resolves upon adding files to the repository staging area\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  add(...filename: string[]): Promise<void>;\n\n  /**\n   * Add all \"unstaged\" files to the repository staging area.\n   *\n   * @returns promise which resolves upon adding files to the repository staging area\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  addAllUnstaged(): Promise<void>;\n\n  /**\n   * Add all untracked files to the repository staging area.\n   *\n   * @returns promise which resolves upon adding files to the repository staging area\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  addAllUntracked(): Promise<void>;\n\n  /**\n   * Add the file named fname to the current marker with given mark\n   *\n   * @param fname Filename\n   * @param mark Mark to set\n   */\n  addMark(fname: string, mark: boolean): void;\n\n  /**\n   * Add a remote Git repository to the current repository.\n   *\n   * @param url - remote repository URL\n   * @param name - remote name\n   * @returns promise which resolves upon adding a remote\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  addRemote(url: string, name?: string): Promise<void>;\n\n  /**\n   * Retrieve the repository commit log.\n   *\n   * ## Notes\n   *\n   * -  This API can be used to implicitly check if the current folder is a Git repository.\n   *\n   * @param count - number of commits to retrieve\n   * @returns promise which resolves upon retrieving the repository commit log\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  allHistory(historyCount?: number): Promise<Git.IAllHistory>;\n\n  /**\n   * Checkout a branch.\n   *\n   * ## Notes\n   *\n   * -   If a branch name is provided, checkout the provided branch (with or without creating it)\n   * -   If a filename is provided, checkout the file, discarding all changes.\n   * -   If nothing is provided, checkout all files, discarding all changes.\n   *\n   * TODO: Refactor into separate endpoints for each kind of checkout request\n   *\n   * @param options - checkout options\n   * @returns promise which resolves upon performing a checkout\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  checkout(options?: Git.ICheckoutOptions): Promise<Git.ICheckoutResult>;\n\n  /**\n   * Make request to checkout the specified tag version\n   *\n   * @param tag of the version to checkout\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  checkoutTag(tag: string): Promise<Git.ICheckoutResult>;\n\n  /**\n   * Clone a repository.\n   *\n   * @param path - local path into which the repository will be cloned\n   * @param url - Git repository URL\n   * @param auth - remote repository authentication information\n   * @returns promise which resolves upon cloning a repository\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  clone(path: string, url: string, auth?: Git.IAuth): Promise<Git.ICloneResult>;\n\n  /**\n   * Commit all staged file changes.\n   *\n   * @param message - commit message\n   * @returns promise which resolves upon committing file changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  commit(message: string): Promise<void>;\n\n  /**\n   * Get (or set) Git configuration options.\n   *\n   * @param options - configuration options to set\n   * @returns promise which resolves upon either getting or setting configuration options\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  config(options?: JSONObject): Promise<JSONObject | void>;\n\n  /**\n   * Fetch commit information.\n   *\n   * @param hash - commit hash\n   * @returns promise which resolves upon retrieving commit information\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  detailedLog(hash: string): Promise<Git.ISingleCommitFilePathInfo>;\n\n  /**\n   * Ensure a .gitignore file exists\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  ensureGitignore(): Promise<void>;\n\n  /**\n   * Get current mark of file named fname\n   *\n   * @param fname Filename\n   * @returns Mark of the file\n   */\n  getMark(fname: string): boolean;\n\n  /**\n   * Gets the path of the file relative to the Jupyter server root.\n   *\n   * If no path is provided, returns the Git repository top folder relative path.\n   * If no Git repository selected, return null\n   *\n   * @param path the file path relative to Git repository top folder\n   * @returns Relative file path to the server root\n   */\n  getRelativeFilePath(path?: string): string | null;\n\n  /**\n   * Add an entry in .gitignore file\n   *\n   * @param filename The name of the entry to ignore\n   * @param useExtension Ignore all files having the same extension as filename\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  ignore(filename: string, useExtension: boolean): Promise<void>;\n\n  /**\n   * Initialize a new Git repository at a specified path.\n   *\n   * @param path - path at which initialize a Git repository\n   * @returns promise which resolves upon initializing a Git repository\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  init(path: string): Promise<void>;\n\n  /**\n   * Retrieve commit logs.\n   *\n   * @param count - number of commits\n   * @returns promise which resolves upon retrieving commit logs\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  log(historyCount?: number): Promise<Git.ILogResult>;\n\n  /**\n   * Fetch changes from a remote repository.\n   *\n   * @param auth - remote authentication information\n   * @returns promise which resolves upon fetching changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  pull(auth?: Git.IAuth): Promise<Git.IPushPullResult>;\n\n  /**\n   * Push local changes to a remote repository.\n   *\n   * @param auth - remote authentication information\n   * @returns promise which resolves upon pushing changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  push(auth?: Git.IAuth): Promise<Git.IPushPullResult>;\n\n  /**\n   * General Git refresh\n   */\n  refresh(): Promise<void>;\n\n  /**\n   * Make request for a list of all Git branches\n   */\n  refreshBranch(): Promise<void>;\n\n  /**\n   * Request Git status refresh\n   */\n  refreshStatus(): Promise<void>;\n\n  /**\n   * Register a new diff provider for specified file types\n   *\n   * @param filetypes File type list\n   * @param callback Callback to use for the provided file types\n   */\n  registerDiffProvider(filetypes: string[], callback: Git.IDiffCallback): void;\n\n  /**\n   * Move files from the \"staged\" to the \"unstaged\" area.\n   *\n   * ## Notes\n   *\n   * -  If no filename is provided, moves all files from the \"staged\" to the \"unstaged\" area.\n   *\n   * @param filename - file path to be reset\n   * @returns promise which resolves upon moving files\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  reset(filename?: string): Promise<void>;\n\n  /**\n   * Reset the repository to a specified commit.\n   *\n   * ## Notes\n   *\n   * -   If a commit hash is not provided, resets the repository to `HEAD`.\n   *\n   * @param hash - commit identifier (hash)\n   * @returns promises which resolves upon resetting the repository\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  resetToCommit(hash: string): Promise<void>;\n\n  /**\n   * Revert changes made after a specified commit.\n   *\n   * @param message - commit message\n   * @param hash - commit identifier (hash)\n   * @returns promise which resolves upon reverting changes\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  revertCommit(message: string, hash: string): Promise<void>;\n\n  /**\n   * Make request for the prefix path of a directory 'path',\n   * with respect to the root directory of repository\n   *\n   * @param path Path for which the prefix is searched for\n   * @returns Path prefix\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  showPrefix(path: string): Promise<Git.IShowPrefixResult>;\n\n  /**\n   * Make request for top level path of repository 'path'\n   *\n   * @param path Path from which the top Git repository needs to be found\n   *\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  showTopLevel(path: string): Promise<Git.IShowTopLevelResult>;\n\n  /**\n   * Make request to list all the tags present in the remote repo\n   *\n   * @returns list of tags\n   *\n   * @throws {Git.NotInRepository} If the current path is not a Git repository\n   * @throws {Git.GitResponseError} If the server response is not ok\n   * @throws {ServerConnection.NetworkError} If the request cannot be made\n   */\n  tags(): Promise<Git.ITagResult>;\n\n  /**\n   * Toggle the mark for the file named fname\n   *\n   * @param fname Filename\n   */\n  toggleMark(fname: string): void;\n}\n\nexport namespace Git {\n  /** Function type for diffing a file's revisions */\n  export type IDiffCallback = (\n    filename: string,\n    revisionA: string,\n    revisionB: string\n  ) => void;\n\n  /**\n   * Interface for GitAllHistory request result,\n   * has all repo information\n   */\n  export interface IAllHistory {\n    code: number;\n    data?: {\n      show_top_level?: IShowTopLevelResult;\n      branch?: IBranchResult;\n      log?: ILogResult;\n      status?: IStatusResult;\n    };\n  }\n\n  /**\n   * Interface for server settings\n   */\n  export interface IServerSettings {\n    /**\n     * Frontend version formatted as Python package version\n     */\n    frontendVersion?: string;\n    /**\n     * Git version (X.Y.Z)\n     */\n    gitVersion?: string;\n    /**\n     * Server absolute root path (as posix)\n     */\n    serverRoot: string;\n    /**\n     * Server extension version formatted as Python package version\n     */\n    serverVersion: string;\n  }\n\n  /** Interface for GitShowTopLevel request result,\n   * has the Git root directory inside a repository\n   */\n  export interface IShowTopLevelResult {\n    code: number;\n    top_repo_path?: string;\n  }\n\n  /** Interface for GitShowPrefix request result,\n   * has the prefix path of a directory in a repository,\n   * with respect to the root directory.\n   */\n  export interface IShowPrefixResult {\n    code: number;\n    under_repo_path?: string;\n  }\n\n  /**\n   * Interface to call the checkout method\n   *\n   * If a branch name is provided, check it out (with or without creating it)\n   * If a filename is provided, check the file out\n   * If nothing is provided, check all files out\n   */\n  export interface ICheckoutOptions {\n    /**\n     * Branch name\n     */\n    branchname?: string;\n    /**\n     * Is it a new branch?\n     */\n    newBranch?: boolean;\n    /**\n     * The commit (branch name, tag, or commit id) to which a new branch HEAD will point.\n     */\n    startpoint?: string;\n    /**\n     * Filename\n     */\n    filename?: string;\n  }\n\n  /** Interface for GitCheckout request result.\n   * For reporting errors in checkout\n   */\n  export interface ICheckoutResult {\n    code: number;\n    message?: string;\n  }\n\n  /**\n   * Branch description interface\n   */\n  export interface IBranch {\n    is_current_branch: boolean;\n    is_remote_branch: boolean;\n    name: string;\n    upstream: string;\n    top_commit: string;\n    tag: string;\n  }\n\n  /** Interface for GitBranch request result,\n   * has the result of fetching info on all branches\n   */\n  export interface IBranchResult {\n    code: number;\n    branches?: IBranch[];\n    current_branch?: IBranch;\n  }\n\n  /**\n   * Data interface of diffcontent request\n   */\n  export interface IDiffContent {\n    /**\n     * Current file content\n     */\n    curr_content: string;\n    /**\n     * Previous file content\n     */\n    prev_content: string;\n  }\n\n  /** Interface for GitStatus request result,\n   * has the status of each changed file\n   */\n  export interface IStatusFileResult {\n    x: string;\n    y: string;\n    to: string;\n    from: string;\n    is_binary: boolean | null;\n    // filetype as determined by app.docRegistry\n    type?: DocumentRegistry.IFileType;\n  }\n\n  /**\n   * Changed file attributes\n   */\n  export interface IStatusFile extends IStatusFileResult {\n    status: Status;\n  }\n\n  /** Interface for GitStatus request result,\n   * has the status of the entire repo\n   */\n  export interface IStatusResult {\n    code: number;\n    files?: IStatusFileResult[];\n  }\n\n  /** Interface for changed_files request result\n   * lists the names of files that have differences between two commits\n   * or beween two branches, or that were changed by a single commit\n   */\n  export interface IChangedFilesResult {\n    code: number;\n    files?: string[];\n  }\n\n  /** Interface for GitLog request result,\n   * has the info of a single past commit\n   */\n  export interface ISingleCommitInfo {\n    commit: string;\n    author: string;\n    date: string;\n    commit_msg: string;\n    pre_commit: string;\n  }\n\n  /** Interface for GitCommit request result,\n   * has the info of a committed file\n   */\n  export interface ICommitModifiedFile {\n    modified_file_path: string;\n    modified_file_name: string;\n    insertion: string;\n    deletion: string;\n    is_binary: boolean | null;\n    // filetype as determined by app.docRegistry\n    type?: DocumentRegistry.IFileType;\n  }\n\n  /** Interface for GitDetailedLog request result,\n   * has the detailed info of a single past commit\n   */\n  export interface ISingleCommitFilePathInfo {\n    code: number;\n    modified_file_note?: string;\n    modified_files_count?: string;\n    number_of_insertions?: string;\n    number_of_deletions?: string;\n    modified_files?: ICommitModifiedFile[];\n  }\n\n  /** Interface for GitLog request result,\n   * has the info of all past commits\n   */\n  export interface ILogResult {\n    code: number;\n    commits?: ISingleCommitInfo[];\n  }\n\n  export interface IIdentity {\n    name: string;\n    email: string;\n  }\n\n  /**\n   * Interface for the Git Auth request.\n   */\n  export interface IAuth {\n    username: string;\n    password: string;\n  }\n\n  /**\n   * Structure for the request to the Git Clone API.\n   */\n  export interface IGitClone {\n    current_path: string;\n    clone_url: string;\n    auth?: IAuth;\n  }\n\n  /**\n   * Structure for the request to the Git Clone API.\n   */\n  export interface IPushPull {\n    current_path: string;\n    auth?: IAuth;\n    cancel_on_conflict?: boolean;\n  }\n\n  /**\n   * Structure for the result of the Git Clone API.\n   */\n  export interface ICloneResult {\n    code: number;\n    message?: string;\n  }\n\n  /**\n   * Structure for the result of the Git Push & Pull API.\n   */\n  export interface IPushPullResult {\n    code: number;\n    message?: string;\n  }\n\n  /**\n   * Interface for a marker obj\n   */\n  export interface IBranchMarker {\n    add(fname: string, mark: boolean): void;\n\n    get(fname: string): boolean;\n\n    set(fname: string, mark: boolean): void;\n\n    toggle(fname: string): void;\n  }\n\n  export type Status =\n    | 'untracked'\n    | 'staged'\n    | 'unstaged'\n    | 'partially-staged'\n    | null;\n\n  export interface ITagResult {\n    code: number;\n    message?: string;\n    tags?: string[];\n  }\n\n  /**\n   * A wrapped error for a fetch response.\n   */\n  export class GitResponseError extends ServerConnection.ResponseError {\n    /**\n     * Create a new response error.\n     */\n    constructor(\n      response: Response,\n      message = `Invalid response: ${response.status} ${response.statusText}`,\n      traceback = '',\n      json: ReadonlyJSONObject = {}\n    ) {\n      super(response, message);\n      this.traceback = traceback; // traceback added in mother class in 2.2.x\n      this._json = json;\n    }\n\n    /**\n     * The error response JSON body\n     */\n    get json(): ReadonlyJSONObject {\n      return this._json;\n    }\n\n    /**\n     * The traceback associated with the error.\n     */\n    traceback: string;\n\n    protected _json: ReadonlyJSONObject;\n  }\n  export class NotInRepository extends Error {\n    constructor() {\n      super('Not in a Git Repository');\n    }\n  }\n}\n\n/**\n * Log message severity.\n */\nexport enum Level {\n  SUCCESS = 10,\n  INFO = 20,\n  RUNNING = 30,\n  WARNING = 40,\n  ERROR = 50\n}\n\n/**\n * Interface describing a component log message.\n */\nexport interface ILogMessage {\n  /**\n   * Error object.\n   */\n  error?: Error;\n\n  /**\n   * Message level.\n   */\n  level: Level;\n\n  /**\n   * Message text.\n   */\n  message: string;\n}\n"]}